/* eslint-disable no-continue, max-params, no-template-curly-in-string, no-regex-spaces */

import fs from 'node:fs';
import path from 'node:path';
import process from 'node:process';

function parseArgs(argv) {
  let openapiPath = '../obsidian-admin-laravel/docs/openapi.yaml';
  let snapshotPath = '../obsidian-admin-laravel/docs/api-contract.snapshot';
  let outputPath = 'src/typings/api/openapi-generated.d.ts';

  for (const arg of argv) {
    if (arg.startsWith('--openapi=')) {
      openapiPath = arg.slice('--openapi='.length);
      continue;
    }

    if (arg.startsWith('--snapshot=')) {
      snapshotPath = arg.slice('--snapshot='.length);
      continue;
    }

    if (arg.startsWith('--output=')) {
      outputPath = arg.slice('--output='.length);
    }
  }

  return {
    openapiPath,
    snapshotPath,
    outputPath
  };
}

function normalizePath(rawPath) {
  const trimmed = String(rawPath ?? '').trim();
  if (trimmed === '') {
    return '/';
  }

  let normalized = trimmed.replace(/^api\/v1\//, '/').replace(/^api\//, '/');
  if (!normalized.startsWith('/')) {
    normalized = `/${normalized}`;
  }

  return normalized.replace(/\/{2,}/g, '/');
}

function parseContractSnapshot(snapshotRaw) {
  const lines = snapshotRaw
    .split(/\r?\n/g)
    .map(line => line.trim())
    .filter(line => line !== '' && !line.startsWith('#'));

  /** @type {Map<string, Set<string>>} */
  const pathMethodMap = new Map();

  for (const line of lines) {
    const match = line.match(/^([A-Z]+)\s+(.+)$/);
    if (!match) {
      continue;
    }

    const method = String(match[1]).toUpperCase();
    const endpointPath = normalizePath(match[2]);
    const methodSet = pathMethodMap.get(endpointPath) ?? new Set();
    methodSet.add(method);
    pathMethodMap.set(endpointPath, methodSet);
  }

  return pathMethodMap;
}

function parseOpenApiSchemaNames(openapiRaw) {
  const schemaNames = new Set();
  const componentsIndex = openapiRaw.indexOf('\ncomponents:');
  if (componentsIndex < 0) {
    return [];
  }

  const componentsBlock = openapiRaw.slice(componentsIndex);
  const schemasMatch = componentsBlock.match(/\n  schemas:\n([\s\S]*)$/);
  if (!schemasMatch) {
    return [];
  }

  const schemaBlock = schemasMatch[1];
  const regex = /^    ([A-Za-z_][A-Za-z0-9_]*)\s*:/gm;
  let match = regex.exec(schemaBlock);
  while (match) {
    schemaNames.add(match[1]);
    match = regex.exec(schemaBlock);
  }

  return Array.from(schemaNames).sort((a, b) => a.localeCompare(b));
}

function templateLiteralFromPath(endpointPath) {
  if (!endpointPath.includes('{')) {
    return `'${endpointPath}'`;
  }

  const template = endpointPath.replace(/\{[^}]+\}/g, '${string}');
  return `\`${template}\``;
}

function renderPathMethodMap(pathMethodMap) {
  const paths = Array.from(pathMethodMap.keys()).sort((a, b) => a.localeCompare(b));
  const pathType = paths.length > 0 ? paths.map(templateLiteralFromPath).join(' | ') : 'never';

  const methodLines = paths.map(endpointPath => {
    const methods = Array.from(pathMethodMap.get(endpointPath) ?? []).sort((a, b) => a.localeCompare(b));
    const methodUnion = methods.map(method => `'${method}'`).join(' | ') || 'never';
    return `    '${endpointPath}': ${methodUnion};`;
  });

  return {
    pathType,
    methodLines
  };
}

function render(schemaNames, pathMethodMap, sourceOpenApiPath, sourceSnapshotPath) {
  const { pathType, methodLines } = renderPathMethodMap(pathMethodMap);
  const schemaType = schemaNames.length > 0 ? schemaNames.map(name => `'${name}'`).join(' | ') : 'never';

  return `/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * Generated by \`pnpm api:types\`.
 *
 * Sources:
 * - ${sourceOpenApiPath}
 * - ${sourceSnapshotPath}
 */
declare namespace BackendContract {
  type EndpointPath = ${pathType};

  interface EndpointMethodMap {
${methodLines.join('\n')}
  }
}

declare namespace OpenAPIContract {
  type SchemaName = ${schemaType};
}
`;
}

function main() {
  const args = parseArgs(process.argv.slice(2));
  const resolvedOpenapiPath = path.resolve(process.cwd(), args.openapiPath);
  const resolvedSnapshotPath = path.resolve(process.cwd(), args.snapshotPath);
  const resolvedOutputPath = path.resolve(process.cwd(), args.outputPath);

  if (!fs.existsSync(resolvedOpenapiPath)) {
    console.error(`OpenAPI file not found: ${resolvedOpenapiPath}`);
    process.exit(1);
  }

  if (!fs.existsSync(resolvedSnapshotPath)) {
    console.error(`Contract snapshot file not found: ${resolvedSnapshotPath}`);
    process.exit(1);
  }

  const openapiRaw = fs.readFileSync(resolvedOpenapiPath, 'utf8');
  const snapshotRaw = fs.readFileSync(resolvedSnapshotPath, 'utf8');

  const schemaNames = parseOpenApiSchemaNames(openapiRaw);
  const pathMethodMap = parseContractSnapshot(snapshotRaw);

  fs.mkdirSync(path.dirname(resolvedOutputPath), { recursive: true });
  fs.writeFileSync(resolvedOutputPath, render(schemaNames, pathMethodMap, args.openapiPath, args.snapshotPath), 'utf8');

  console.log(`Generated backend contract typings: ${resolvedOutputPath}`);
}

main();
